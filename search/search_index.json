{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction LINQPadless compiles and runs LINQPad query files as stand-alone .NET Core applications, without the need for LINQPad. The LINQPad query file can be run on any platform where .NET Core is supported however it is the responsibility of the query author to ensure that the code and packages referenced are compatible with .NET Core as well as the execution platform. LINQPadless is designed to feel like a scripting environment. All you need to maintain are your LINQPad query files. At time of execution, LINQPadless turns them into full programs, then compiles and executes them. The compilation is cached and re-used until the source query file changes so while the first execution may seem slow, subsequent ones run fast. The compilation requires an installation of .NET Core SDK 2.1 or a later version.","title":"Introduction"},{"location":"#introduction","text":"LINQPadless compiles and runs LINQPad query files as stand-alone .NET Core applications, without the need for LINQPad. The LINQPad query file can be run on any platform where .NET Core is supported however it is the responsibility of the query author to ensure that the code and packages referenced are compatible with .NET Core as well as the execution platform. LINQPadless is designed to feel like a scripting environment. All you need to maintain are your LINQPad query files. At time of execution, LINQPadless turns them into full programs, then compiles and executes them. The compilation is cached and re-used until the source query file changes so while the first execution may seem slow, subsequent ones run fast. The compilation requires an installation of .NET Core SDK 2.1 or a later version.","title":"Introduction"},{"location":"limitations/","text":"Limitations Requires .NET Core SDK 2.1+ for execution. LINQPad Query files must be either C# Statements, Expression or Program. LINQPad-specific methods like Dump and those on its Util class will cause compilation errors.","title":"Limitations"},{"location":"limitations/#limitations","text":"Requires .NET Core SDK 2.1+ for execution. LINQPad Query files must be either C# Statements, Expression or Program. LINQPad-specific methods like Dump and those on its Util class will cause compilation errors.","title":"Limitations"},{"location":"motivation/","text":"Motivation Why does LINQPadless exist? LINQPad is an excellent alternative to Visual Studio when you want to script some code but don't want all the ceremony of a Visual Studio solution or project. You can use NuGet packages, get the same experience as IntelliSense, even debug through your code and all the while maintaining a single source file. What's there not to love about it? However, when you want to ship that code to someone or automate it, you are tied to LINQPad when that dependency is not necessary. That's where lpless comes in. It turns your LINQ Query file into a C# script or an executable that you can then run without LINQPad. What's different from lprun ? lprun is a good solution when you need 100% compatibility and parity with LINQPad features at run-time . On the other hand, when all you are doing is using LINQPad as a lightweight IDE to script some task that doesn't need its bells and whistles then turning those queries into compiled executables enables them be shipped and run without LINQPad.","title":"Motivation"},{"location":"motivation/#motivation","text":"","title":"Motivation"},{"location":"motivation/#why-does-linqpadless-exist","text":"LINQPad is an excellent alternative to Visual Studio when you want to script some code but don't want all the ceremony of a Visual Studio solution or project. You can use NuGet packages, get the same experience as IntelliSense, even debug through your code and all the while maintaining a single source file. What's there not to love about it? However, when you want to ship that code to someone or automate it, you are tied to LINQPad when that dependency is not necessary. That's where lpless comes in. It turns your LINQ Query file into a C# script or an executable that you can then run without LINQPad.","title":"Why does LINQPadless exist?"},{"location":"motivation/#whats-different-from-lprun","text":"lprun is a good solution when you need 100% compatibility and parity with LINQPad features at run-time . On the other hand, when all you are doing is using LINQPad as a lightweight IDE to script some task that doesn't need its bells and whistles then turning those queries into compiled executables enables them be shipped and run without LINQPad.","title":"What's different from lprun?"},{"location":"tutorial/","text":"Tutorial The simplest way to take LINQPadless for a spin is to try it in a Docker container. Assuming you have Docker installed for your operating system, start by cloning the project's repository : git clone https://github.com/atifaziz/LinqPadless.git LinqPadless Next, make the working directory of the clone the current working directory of your shell. In most shells, you can do this with: cd LinqPadless Build the Docker image as follows (it will be named/tagged lpless ): docker build --rm -t lpless . Once the image is built, run a container as follows: docker run --rm -it --entrypoint /bin/sh lpless The --entrypoint /bin/sh is necessary to enter the shell of the container image (based on Alpine Linux ) so you can explore running LINQPadless. Without changing the entry-point of the image, LINQPadless will just run, display its help and exit. Once the container is running, you will see a shell prompt with /scripts/linq as your current directory: /scripts/linq # \u2588 For the purpose of this tutorial, \u2588 represents your cursor. Copy and paste the following on the shell prompt to create a tiny LINQPad query file that has the C# expression DateTime.Now : cat > Now . linq << EOF < Query Kind = \"Expression\" /> DateTime . Now EOF Everything between <<EOF and EOF will become the content of the file Now.linq . If you have never opened a LINQPad query file in a plain text editor then the above may seem strange. In short, LINQPad query files are plain text files that have the following structure: a header that is an XML element containing LINQPad meta data a blank line that separates the header from the remaining content body of code (expression, statements or program) The <Query Kind=\"Expression\" /> that we placed in the header of the Now.linq file says that the code DateTime.Now is a C# expression. Your shell session should now be looking as follows: /scripts/linq # cat > Now.linq <<EOF > <Query Kind=\"Expression\" /> > > DateTime.Now > EOF /scripts/linq # \u2588 Let's run it by typing lpless Now.linq at the shell prompt. After a few seconds, you should see the current time appear as shown below: /scripts/linq # lpless Now.linq 8/25/2020 4:48:42 PM /scripts/linq # \u2588 If you run it as second time, you should notice that it executes almost instantly. LINQPadless caches the results of previous compilations and re-uses them if there have been no changes to the source files. In fact, let's time the execution with time lpless Now.linq : /scripts/linq # time lpless Now.linq 8/25/2020 4:50:14 PM real 0m 0.35s user 0m 0.33s sys 0m 0.04s You can see that it executed in a fraction of a second. We can force a re-compilation even if a cached version is available by adding the --force flag (or just -f for short) before the query file name. /scripts/linq # time lpless --force Now.linq 8/25/2020 4:50:55 PM real 0m 2.55s user 0m 2.44s sys 0m 0.30s Notice how it took substantially longer time to run. If you copy the file and run the copy, it will also run quickly: /scripts/linq # cp Now.linq Now2.linq /scripts/linq # time lpless Now2.linq 8/25/2020 4:57:46 PM real 0m 0.41s user 0m 0.38s sys 0m 0.04s LINQPadless is smart enough to re-use a previous compilation across sources if they match. Internally, it computes a digest/hash of the file content and uses that to look-up a compilation in its on-disk cache. Since Now.linq and Now2.linq are copies of each other, running the copy is just as fast the original. Let's explore a LINQPad query file with C# statements: cat > Statements . linq << EOF < Query Kind = \"Statements\" /> Console . WriteLine ( DateTime . Now ); EOF Run it with lpless Statements.linq : /scripts/linq # cat > Statements.linq <<EOF > <Query Kind=\"Statements\" /> > > Console.WriteLine(DateTime.Now); > EOF /scripts/linq # lpless Statements.linq 8/25/2020 5:04:26 PM /scripts/linq # \u2588 It prints the current date and time like the first example, but since the XML header <Query Kind=\"Statements\" /> says the file contains statements, the date and time had to be printed to the console as a regular C# statement using: Console . WriteLine ( DateTime . Now ); Let's append another statement to the same file that prints Hello! : /scripts/linq # echo 'Console.WriteLine(\"Hello!\");' >> Statements.linq /scripts/linq # lpless Statements.linq 8/25/2020 5:08:13 PM Hello! Since Statements.linq was modified, you will notice the compilation delay when lpless Statements.linq executes. The final type of LINQPad query file supported by LINQPadless is a C# program, but for this, let's try something more complicated. A slightly modified version of the dotnet-cowsay project has been shared at the following URL: http://share.linqpad.net/9bfa4d.linq . You open download and open it up in LINQPad if you want to take a peek inside, even run it! The program selects a random blog article from Discover .NET and then displays an ASCII cow with a speech bubble containing the selected blog title, article title and article URL. It is a variant of the popular cowsay program. Back in the Docker container shel prompt, download the LINQPad query file to disk: wget -q -O cowsay.linq http://share.linqpad.net/9bfa4d.linq and then run it: lpless cowsay.linq You should then see an output like this: \u280f Looking for an awesome article .. _________________________________________________________ / Evgeny Zborovsky \\ | Using Native Facebook Login Button in Xamarin . Forms QA | \\ https : // evgenyzborovsky . com / 2019 / 09 / 10 / facebook - sdk - qa / / --------------------------------------------------------- \\ ^ __ ^ \\ ( oo ) \\ _______ ( __ ) \\ ) \\ / \\ || ----w | || ||","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"The simplest way to take LINQPadless for a spin is to try it in a Docker container. Assuming you have Docker installed for your operating system, start by cloning the project's repository : git clone https://github.com/atifaziz/LinqPadless.git LinqPadless Next, make the working directory of the clone the current working directory of your shell. In most shells, you can do this with: cd LinqPadless Build the Docker image as follows (it will be named/tagged lpless ): docker build --rm -t lpless . Once the image is built, run a container as follows: docker run --rm -it --entrypoint /bin/sh lpless The --entrypoint /bin/sh is necessary to enter the shell of the container image (based on Alpine Linux ) so you can explore running LINQPadless. Without changing the entry-point of the image, LINQPadless will just run, display its help and exit. Once the container is running, you will see a shell prompt with /scripts/linq as your current directory: /scripts/linq # \u2588 For the purpose of this tutorial, \u2588 represents your cursor. Copy and paste the following on the shell prompt to create a tiny LINQPad query file that has the C# expression DateTime.Now : cat > Now . linq << EOF < Query Kind = \"Expression\" /> DateTime . Now EOF Everything between <<EOF and EOF will become the content of the file Now.linq . If you have never opened a LINQPad query file in a plain text editor then the above may seem strange. In short, LINQPad query files are plain text files that have the following structure: a header that is an XML element containing LINQPad meta data a blank line that separates the header from the remaining content body of code (expression, statements or program) The <Query Kind=\"Expression\" /> that we placed in the header of the Now.linq file says that the code DateTime.Now is a C# expression. Your shell session should now be looking as follows: /scripts/linq # cat > Now.linq <<EOF > <Query Kind=\"Expression\" /> > > DateTime.Now > EOF /scripts/linq # \u2588 Let's run it by typing lpless Now.linq at the shell prompt. After a few seconds, you should see the current time appear as shown below: /scripts/linq # lpless Now.linq 8/25/2020 4:48:42 PM /scripts/linq # \u2588 If you run it as second time, you should notice that it executes almost instantly. LINQPadless caches the results of previous compilations and re-uses them if there have been no changes to the source files. In fact, let's time the execution with time lpless Now.linq : /scripts/linq # time lpless Now.linq 8/25/2020 4:50:14 PM real 0m 0.35s user 0m 0.33s sys 0m 0.04s You can see that it executed in a fraction of a second. We can force a re-compilation even if a cached version is available by adding the --force flag (or just -f for short) before the query file name. /scripts/linq # time lpless --force Now.linq 8/25/2020 4:50:55 PM real 0m 2.55s user 0m 2.44s sys 0m 0.30s Notice how it took substantially longer time to run. If you copy the file and run the copy, it will also run quickly: /scripts/linq # cp Now.linq Now2.linq /scripts/linq # time lpless Now2.linq 8/25/2020 4:57:46 PM real 0m 0.41s user 0m 0.38s sys 0m 0.04s LINQPadless is smart enough to re-use a previous compilation across sources if they match. Internally, it computes a digest/hash of the file content and uses that to look-up a compilation in its on-disk cache. Since Now.linq and Now2.linq are copies of each other, running the copy is just as fast the original. Let's explore a LINQPad query file with C# statements: cat > Statements . linq << EOF < Query Kind = \"Statements\" /> Console . WriteLine ( DateTime . Now ); EOF Run it with lpless Statements.linq : /scripts/linq # cat > Statements.linq <<EOF > <Query Kind=\"Statements\" /> > > Console.WriteLine(DateTime.Now); > EOF /scripts/linq # lpless Statements.linq 8/25/2020 5:04:26 PM /scripts/linq # \u2588 It prints the current date and time like the first example, but since the XML header <Query Kind=\"Statements\" /> says the file contains statements, the date and time had to be printed to the console as a regular C# statement using: Console . WriteLine ( DateTime . Now ); Let's append another statement to the same file that prints Hello! : /scripts/linq # echo 'Console.WriteLine(\"Hello!\");' >> Statements.linq /scripts/linq # lpless Statements.linq 8/25/2020 5:08:13 PM Hello! Since Statements.linq was modified, you will notice the compilation delay when lpless Statements.linq executes. The final type of LINQPad query file supported by LINQPadless is a C# program, but for this, let's try something more complicated. A slightly modified version of the dotnet-cowsay project has been shared at the following URL: http://share.linqpad.net/9bfa4d.linq . You open download and open it up in LINQPad if you want to take a peek inside, even run it! The program selects a random blog article from Discover .NET and then displays an ASCII cow with a speech bubble containing the selected blog title, article title and article URL. It is a variant of the popular cowsay program. Back in the Docker container shel prompt, download the LINQPad query file to disk: wget -q -O cowsay.linq http://share.linqpad.net/9bfa4d.linq and then run it: lpless cowsay.linq You should then see an output like this: \u280f Looking for an awesome article .. _________________________________________________________ / Evgeny Zborovsky \\ | Using Native Facebook Login Button in Xamarin . Forms QA | \\ https : // evgenyzborovsky . com / 2019 / 09 / 10 / facebook - sdk - qa / / --------------------------------------------------------- \\ ^ __ ^ \\ ( oo ) \\ _______ ( __ ) \\ ) \\ / \\ || ----w | || ||","title":"Tutorial"},{"location":"workings/","text":"Usage LINQPadless works by converting LINQPad query files ( *.linq ) into full-fledged C# programs that then get compiled and executed. To compile, it requires the .NET Core SDK . The compilation of a query is cached so that subsequent runs are quick by skipping the conversion and compilation steps. A program template is used to convert a LINQPad query file ( *.linq ) into a full-fledged C# program. The template is just a normal C# project with one or more source files where placeholders and conditional compilation drive the final code that will run. When LINQPadless is given a LINQPad query file, it first determines if a previous compilation exists in the cache that can be re-used. It starts by computing a hash of the query file's content. The cache is located in .lpless/cache Generate a hash with the content of the LINQPad query file. Look-up the hash in the cache. If a compilation exists under the hash then execute it and skip all subsequent steps. Locate a C# project template and use it to convert the code of the LINQPad query file into a full-fledged C# program. Compile the project created from the template in the previous step and store the compilation in the cache under the hash computed in step 1. Execute the compiled binary in the cache.","title":"Usage"},{"location":"workings/#usage","text":"LINQPadless works by converting LINQPad query files ( *.linq ) into full-fledged C# programs that then get compiled and executed. To compile, it requires the .NET Core SDK . The compilation of a query is cached so that subsequent runs are quick by skipping the conversion and compilation steps. A program template is used to convert a LINQPad query file ( *.linq ) into a full-fledged C# program. The template is just a normal C# project with one or more source files where placeholders and conditional compilation drive the final code that will run. When LINQPadless is given a LINQPad query file, it first determines if a previous compilation exists in the cache that can be re-used. It starts by computing a hash of the query file's content. The cache is located in .lpless/cache Generate a hash with the content of the LINQPad query file. Look-up the hash in the cache. If a compilation exists under the hash then execute it and skip all subsequent steps. Locate a C# project template and use it to convert the code of the LINQPad query file into a full-fledged C# program. Compile the project created from the template in the previous step and store the compilation in the cache under the hash computed in step 1. Execute the compiled binary in the cache.","title":"Usage"}]}